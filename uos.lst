
; 64tass Turbo Assembler Macro V1.53.1515 listing file
; 64tass -a -o ./target/uos.prg -L uos.lst ./src/uos.asm
; Sun Jun 23 14:18:33 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: ./src/uos.asm


;******  Processing file: ./src/uos.inc

=$02					X1          = $02
=$04					Y1          = $04
=$06					X2          = $06
=$08					Y2          = $08
=$1000					APP_START   = $1000
=$1500					APP_CLICK   = $1500
=$c01b					InitGr      = $c01b
=$c036					GPLOT       = $c036
=$c0c9					GRON        = $c0c9
=$c172					GROFF       = $c172
=$c18d					SETCOLOR    = $c18d
=$c1ac					LINE        = $c1ac
=$c379					CIRCLE      = $c379
=$c583					GPRINT      = $c583
=$9f09					install1    = $9f09

;******  Return to file: ./src/uos.asm


;******  Processing file: ./src/kernal.inc

=$ff81					CINT   = $FF81;  ----  FF5B  init VIC & screen editor                                                  - - -  - - -  A X Y
=$ff84					IOINIT = $FF84;  ----  FDA3  initialize CIA & IRQ                                                      - - -  - - -  A X Y
=$ff87					RAMTAS = $FF87;  ----  FD50  RAM test & search RAM end                                                 - - -  - - -  A X Y
=$ff8a					RESTOR = $FF8A;  ----  FD15  restore default I/O vectors                                               - - -  - - -  A - Y
=$ff8d					VECTOR = $FF8D;  ----  FD1A  read/set I/O vectors               in: C=0 moves from Y/X to vectors      - X Y  - X -  A - Y
=$ff90					SETMSG = $FF90;  ----  FE18  enable/disable KERNAL messages     in: A bit7=1 error msgs on             A - -  - - -  A - -
=$ff93					SECOND = $FF93;  ----  EDB9  send secondary addr after listen   in: A=secondary address                A - -  - - -  A - -
=$ff96					TKSA   = $FF96;  ----  EDC7  send secondary addr after talk     in: A=secondary address                A - -  - - -  A - -
=$ff99					MEMTOP = $FF99;  ----  FE25  read/set top of memory             in: C=0; Y/X address                   - X Y  - X Y  - - -
=$ff9c					MEMBOT = $FF9C;  ----  FE34  read/set bottom of memory          in: C=0; Y/X address                   - X Y  - X Y  - - -
=$ff9f					SCNKEY = $FF9F;  ----  EA87  scan keyboard                                                             - - -  - - -  A X Y
=$ffa2					SETTMO = $FFA2;  ----  FE21  set IEEE timeout                   in: A bit7=1 disable, bit7=0 enable    A - -  A - -  - - -
=$ffa5					ACPTR  = $FFA5;  ----  EE13  input byte from SERIAL             out:A=byte, C=1 and ST=2 if timeout    - - -  A - -  A - -
=$ffa8					CIOUT  = $FFA8;  ----  EDDD  output byte to SERIAL              in: A=byte, C=1 and ST=3 if timeout    A - -  A - -  - - -
=$ffab					UNTLK  = $FFAB;  ----  EDEF  untalk all SERIAL devices                                                 - - -  - - -  A - -
=$ffae					UNLSN  = $FFAE;  ----  EDFE  unlisten all SERIAL devices                                               - - -  - - -  A - -
=$ffb1					LISTEN = $FFB1;  ----  ED0C  make SERIAL device listen          in: A=device number                    A - -  - - -  A - -
=$ffb4					TALK   = $FFB4;  ----  ED09  make SERIAL device talk            in: A=device number                    A - -  - - -  A - -
=$ffb7					READST = $FFB7;  ----  FE07  read I/O status byte               out:A=status byte                      - - -  A - -  A - -
=$ffba					SETLFS = $FFBA;  ----  FE00  set file parameters                in: A=logical file number              A X Y  A X Y  - - -
=$ffbd					SETNAM = $FFBD;  ----  FDF9  set file name                      in: A=length of filename               A X Y  A X Y  - - -
=$ffc0					OPEN   = $FFC0;  031A  F34A  open log.file after SETLFS,SETNAM  out:A=error# if C=1                    - - -  - - -  A X Y
=$ffc3					CLOSE  = $FFC3;  031C  F291  close a logical file               in: A=logical file number              A - -  - - -  A X Y
=$ffc6					CHKIN  = $FFC6;  031E  F20E  open channel for input             in: X=logical file number              - X -  - - -  A X -
=$ffc9					CHKOUT = $FFC9;  0320  F250  open channel for output            in: X=logical file number              - X -  - - -  A X -
=$ffcc					CLRCHN = $FFCC;  0322  F333  restore default devices                                                   - - -  - - -  A X -
=$ffcf					CHRIN  = $FFCF;  0324  F157  input character                    out:A=character, C=1 and ST=error      - - -  A - -  A - -
=$ffd2					CHROUT = $FFD2;  0326  F1CA  output character                   in: A=character, C=1 and ST=error      A - -  A - -  - - -
=$ffd5					LOAD   = $FFD5;  0330  F49E  load after call SETLFS,SETNAM      in: A=0 load, a=1 verify               A X Y  A X Y  A X Y
=$ffd8					SAVE   = $FFD8;  0332  F5DD  save after call SETLFS,SETNAM      in: A=zero page pointer to start.addr  A X Y  - - -  A X Y
=$ffdb					SETTIM = $FFDB;  ----  F6E4  set jiffy clock                    in: A=MSB, X=middle, Y=LSB             A X Y  - - -  - - -
=$ffde					RDTIM  = $FFDE;  ----  F6DD  read jiffy clock                   out:A=MSB, X=middle, Y=LSB             - - -  A X Y  A X Y
=$ffe1					STOP   = $FFE1;  0328  F6ED  check stop key                     out:Z=0 if STOP not used; X unchanged  - - -  A - -  A - -
=$ffe4					GETIN  = $FFE4;  032A  F13E  get a byte from channel            out:keyboard:A=0 if puffer empty       - - -  A - -  A X Y
=$ffe7					CLALL  = $FFE7;  032C  F32F  close or abort all files                                                  - - -  - - -  A X -
=$ffea					UDTIM  = $FFEA;  ----  F69B  update jiffy clock                                                        - - -  - - -  A X -
=$ffed					SCREEN = $FFED;  ----  E505  return screen size                 out:X=columns, Y=rows                  - - -  - X Y  - X Y
=$fff0					PLOT   = $FFF0;  ----  E50A  read/set cursor position           in: C=0, X=row, Y=column               - X Y  - X Y  - - -
=$fff3					IOBASE = $FFF3;  ----  E500  returns the addr of I/O devices    out:Y/X=addr($DC00)                    - - -  - X Y  - X Y

;******  Return to file: ./src/uos.asm


;******  Processing file: ./src/vic-ii.inc

=$d000					VIC_BASE        = $d000
=$d800					VIC_COLOR_RAM   = $d800
=$0400					VIC_HIRES_COLOR = $0400
=$00					VIC_SPR0_X      = $00     ; Sprite x / y screen position registers
=$01					VIC_SPR0_Y      = $01
=$02					VIC_SPR1_X      = $02
=$03					VIC_SPR1_Y      = $03
=$04					VIC_SPR2_X      = $04
=$05					VIC_SPR2_Y      = $05
=$06					VIC_SPR3_X      = $06
=$07					VIC_SPR3_Y      = $07
=$08					VIC_SPR4_X      = $08
=$09					VIC_SPR4_Y      = $09
=$0a					VIC_SPR5_X      = $0A
=$0b					VIC_SPR5_Y      = $0B
=$0c					VIC_SPR6_X      = $0C
=$0d					VIC_SPR6_Y      = $0D
=$0e					VIC_SPR7_X      = $0E
=$0f					VIC_SPR7_Y      = $0F
=$10					VIC_SPR_XMSb    = $10     ; MSB of the X coordinate (since 320 > 255). Bit 7 = sprite 7, 6 = sprite 6, etc
=$11					VIC_CTRL_1      = $11
=$11					SCROLY			= $11     ; Control register 1
=$12					VIC_RASTER      = $12     ; Number of raster line at which a raster IRQ should be generated.
=$13					VIC_LTPEN_X     = $13     ; X-portion of the screen position at which the beam was found when a strobe was generated (light pen)
=$14					VIC_LTPEN_Y     = $14     ; Y-portion of the screen position at which the beam was found when a strobe was generated (light pen)
=$15					VIC_SPR_ENBL    = $15     ; Sprite enable (bit 7= sprite 7, bit 6 = sprite 6 etc)
=$16					VIC_CTRL_2      = $16     ; Control register 2
=$17					VIC_SPR_XPND_X  = $17     ; Sprite expand (bit 7= sprite 7, bit 6 = sprite 6 etc)
=$18					VIC_RAM_BASE    = $18     ; Base address of the character generator and video RAM
=$19					VIC_IRR         = $19     ; IRR:Interrupt Request Register
=$1a					VIC_IMR         = $1a     ; IMR:Interrupt Mask Register
=$1b					VIC_SPR_PRI     = $1b     ; Priority register(sprites)
=$1c					VIC_SPR_MULTI   = $1c     ; Multi-color register (sprites)
=$1d					VIC_SPR_XPND_Y  = $1d     ; Sprite expand Y The sprites can be doubled in the Y-direction by setting
=$1e					VIC_SPSP_COL    = $1e     ; Sprite/sprite collision
=$1f					VIC_SPBK_COL    = $1f     ; Sprite/background collision
=$20					VIC_BORDER_COL  = $20     ; Exterior color(border color) The border color is set in this register (0-15).
=$21					VIC_BG_COL0     = $21     ; Background color registers 0-3
=$22					VIC_BG_COL1     = $22     ; Background color register 0 determines the background color in
=$23					VIC_BG_COL2     = $23     ; the "normal" text mode. If the multi-color mode is enabled, it
=$24					VIC_BG_COL3     = $24     ; accesses registers 1-3
=$25					VIC_SPR_MCOL0   = $25     ; Spritemulti-colorcolor0/1
=$26					VIC_SPR_MCOL1   = $26     ; Sprites which are represented in multi-color can assume the back
=$27					VIC_SPR_COL0    = $27     ; Color sprite 0-8
=$28					VIC_SPR_COL1    = $28     ; The colors for the individual sprites are placed in these registers.
=$29					VIC_SPR_COL2    = $29
=$2a					VIC_SPR_COL3    = $2a
=$2b					VIC_SPR_COL4    = $2b
=$2c					VIC_SPR_COL5    = $2c
=$2d					VIC_SPR_COL6    = $2d
=$2e					VIC_SPR_COL7    = $2e
=$2f					VIC_KYBRD_CTRL  = $2f     ; Keyboard control register
=$30					VIC_CLOCK       = $30     ; 2MHz bit
=$00					VIC_COLOR_BLACK   = $00
=$01					VIC_COLOR_WHITE   = $01
=$02					VIC_COLOR_RED     = $02
=$03					VIC_COLOR_CYAN    = $03
=$04					VIC_COLOR_PURPLE  = $04
=$05					VIC_COLOR_GREEN   = $05
=$06					VIC_COLOR_BLUE    = $06
=$07					VIC_COLOR_YELLOW  = $07
=$08					VIC_COLOR_ORANGE  = $08
=$09					VIC_COLOR_BROWN   = $09
=$0a					VIC_COLOR_LRED    = $0A
=$0b					VIC_COLOR_DGREY   = $0B
=$0c					VIC_COLOR_MGREY   = $0C
=$0d					VIC_COLOR_LGREEN  = $0D
=$0e					VIC_COLOR_LBLUE   = $0E
=$0f					VIC_COLOR_LGREY   = $0F

;******  Return to file: ./src/uos.asm


;******  Processing file: ./src/macros.inc


;******  Return to file: ./src/uos.asm

>0801	0c 08				.byte $0C, $08      ; pointer to next line
>0803	0a 00				.byte $0A, $00      ; line number (10)
>0805	9e				.byte $9E           ; SYS token
>0806	20 32 30 36 32			.text " 2062"       ; SYS address in ASCII
>080b	00 00 00			.byte $00, $00, $00 ; end-of-program
.080e					START:
.080e	a9 00		lda #$00	        lda #$00
.0810	8d 20 d0	sta $d020	        sta VIC_BASE + VIC_BORDER_COL
.0813	a9 00		lda #$00	        lda #$00
.0815	8d 21 d0	sta $d021	        sta VIC_BASE + VIC_BG_COL0
.0818	a9 93		lda #$93	        lda #$93
.081a	20 d2 ff	jsr $ffd2	        jsr CHROUT
.081d					_prmsg1
.081d	a0 00		ldy #$00	        LDY #$00
.081f					_prloop:
.081f	b9 33 08	lda $0833,y	        LDA msg1,Y
.0822	f0 07		beq $082b	        BEQ _prdone
.0824	20 d2 ff	jsr $ffd2	        JSR CHROUT
.0827	c8		iny		        INY
.0828	4c 1f 08	jmp $081f	        JMP _prloop
.082b					_prdone:
.082b	a9 0d		lda #$0d	        LDA #$0D
.082d	20 d2 ff	jsr $ffd2	        JSR CHROUT
.0830	4c 46 08	jmp $0846	        jmp loadfiles
>0833	42 4f 4f 54 49 4e 47 20		msg1:   .text "booting system...", $0d, $00
>083b	53 59 53 54 45 4d 2e 2e 2e 0d 00
.0846					loadfiles:
.0846	20 25 09	jsr $0925	        JSR LOADIMM
>0849	55 4f 53 2d 47 46 58 00			    .text "uos-gfx",$00
.0851	20 cd 08	jsr $08cd	        jsr LOADER
.0854	20 25 09	jsr $0925	        JSR LOADIMM
>0857	55 4f 53 2d 44 52 56 31			    .text "uos-drv1351",$00
>085f	33 35 31 00
.0863	20 cd 08	jsr $08cd	        jsr LOADER
.0866	20 25 09	jsr $0925	        JSR LOADIMM
>0869	55 4f 53 2d 53 50 52 49			    .text "uos-sprites",$00
>0871	54 45 53 00
.0875	20 cd 08	jsr $08cd	        jsr LOADER
.0878	20 25 09	jsr $0925	        JSR LOADIMM
>087b	55 4f 53 2d 44 45 53 4b			    .text "uos-desktop",$00
>0883	54 4f 50 00
.0887	20 cd 08	jsr $08cd	        jsr LOADER
.088a					_setup:
.088a	20 09 9f	jsr $9f09	        jsr install1
.088d	20 1b c0	jsr $c01b	    JSR InitGr
.0890	a9 bf		lda #$bf	    LDA #(VIC_COLOR_DGREY * 16 + VIC_COLOR_LGREY)
.0892	20 c9 c0	jsr $c0c9	    JSR GRON
.0895	a9 01		lda #$01	        lda #$01
.0897	8d 15 d0	sta $d015	        sta VIC_BASE + VIC_SPR_ENBL
.089a	a9 02		lda #$02	        lda #VIC_COLOR_RED
.089c	8d 27 d0	sta $d027	        sta VIC_BASE + VIC_SPR_COL0
.089f	a9 00		lda #$00	        lda #$00        ; $8000 = sprite table
.08a1	8d f8 87	sta $87f8	        sta $87f8
.08a4	a9 80		lda #$80	        lda #$80
.08a6	8d 00 d0	sta $d000	        sta VIC_BASE + VIC_SPR0_X
.08a9	8d 01 d0	sta $d001	        sta VIC_BASE + VIC_SPR0_Y
.08ac	20 00 10	jsr $1000	        jsr APP_START
.08af					_mainloop:
.08af	ad 01 dc	lda $dc01	        lda $dc01
.08b2	29 10		and #$10	        and #%00010000
.08b4	f0 03		beq $08b9	        beq _btnclick
.08b6	4c bc 08	jmp $08bc	        jmp _next
.08b9					_btnclick:
.08b9	20 00 15	jsr $1500	        jsr APP_CLICK
.08bc					_next
.08bc	4c af 08	jmp $08af	        jmp _mainloop
.08bf					TOBASIC:
.08bf	a9 93		lda #$93	    lda #$93
.08c1	20 d2 ff	jsr $ffd2	    jsr CHROUT
.08c4	20 72 c1	jsr $c172	    jsr GROFF
.08c7	a9 01		lda #$01	        lda #$01
.08c9	8d 15 d0	sta $d015	        sta VIC_BASE + VIC_SPR_ENBL
.08cc	60		rts		        RTS
.08cd					LOADER:
.08cd	a0 00		ldy #$00	        LDY #$00
.08cf					_prloop:
.08cf	b9 01 09	lda $0901,y	        LDA file,Y
.08d2	f0 07		beq $08db	        BEQ _prdone
.08d4	20 d2 ff	jsr $ffd2	        JSR CHROUT
.08d7	c8		iny		        INY
.08d8	4c cf 08	jmp $08cf	        JMP _prloop
.08db					_prdone:
.08db	a9 0d		lda #$0d	        LDA #$0D
.08dd	20 d2 ff	jsr $ffd2	        JSR CHROUT
.08e0	ad 00 09	lda $0900	        LDA ftmp
.08e3	a2 01		ldx #$01	        LDX #<file
.08e5	a0 09		ldy #$09	        LDY #>file
.08e7	20 bd ff	jsr $ffbd	        JSR $FFBD     ; call SETNAM
.08ea	a9 01		lda #$01	        LDA #$01
.08ec	a6 ba		ldx $ba		        LDX $BA       ; last used device number
.08ee	d0 02		bne $08f2	        BNE _skip
.08f0	a2 08		ldx #$08	        LDX #$08      ; default to device 8
.08f2	a0 01		ldy #$01	_skip   LDY #$01      ; not $01 means: load to address stored in file
.08f4	20 ba ff	jsr $ffba	        JSR $FFBA     ; call SETLFS
.08f7	a9 00		lda #$00	        LDA #$00      ; $00 means: load to memory (not verify)
.08f9	20 d5 ff	jsr $ffd5	        JSR $FFD5     ; call LOAD
.08fc	b0 01		bcs $08ff	        BCS _error    ; if carry set, a load error has happened
.08fe	60		rts		        RTS
.08ff					_error
.08ff	60		rts		        RTS
>0900	00				ftmp:   .byte $00
>0901	00 00 00 00 00 00 00 00		file:   .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
>0909	00 00 00 00 00 00 00
>0910	55 4f 53 2d 47 46 58 00		files:  .TEXT "uos-gfx", $00
>0918	55 4f 53 2d 44 52 56 31		        .TEXT "uos-drv1351", $00
>0920	33 35 31 00
>0924	00				        .byte $00
.0925					LOADIMM:
.0925	48		pha			PHA     		; save A
.0926	98		tya			TYA			    ; copy Y
.0927	48		pha			PHA  			; save Y
.0928	8a		txa			TXA			    ; copy X
.0929	48		pha			PHA  			; save X
.092a	ba		tsx			TSX			    ; get stack pointer
.092b	bd 04 01	lda $0104,x		LDA $0104,X		; get return address low byte (+4 to correct pointer)
.092e	85 bc		sta $bc			STA $BC			; save in page zero
.0930	bd 05 01	lda $0105,x		LDA $0105,X		; get return address high byte (+5 to correct pointer)
.0933	85 bd		sta $bd			STA $BD			; save in page zero
.0935	a0 01		ldy #$01		LDY #$01		; set index (+1 to allow for return address offset)
.0937					LOADIMM2:
.0937	b1 bc		lda ($bc),y		LDA ($BC),Y		; get byte from string
.0939	f0 0c		beq $0947		BEQ LOADIMM3	; exit if null (end of text)
.093b	88		dey		    DEY
.093c	99 01 09	sta $0901,y		STA file,Y
.093f	c8		iny		    INY
.0940	98		tya		    TYA
.0941	8d 00 09	sta $0900	    STA ftmp
.0944	c8		iny		    INY			    ; increment index
.0945	d0 f0		bne $0937		BNE LOADIMM2	; loop (exit if 256th character)
.0947					LOADIMM3:
.0947	98		tya			TYA			    ; copy index
.0948	18		clc			CLC			    ; clear carry
.0949	65 bc		adc $bc			ADC $BC			; add string pointer low byte to index
.094b	9d 04 01	sta $0104,x		STA $0104,X		; put on stack as return address low byte
.094e	a9 00		lda #$00		LDA #$00		; clear A
.0950	65 bd		adc $bd			ADC $BD		    ; add string pointer high byte
.0952	9d 05 01	sta $0105,x		STA $0105,X		; put on stack as return address high byte
.0955	68		pla			PLA			    ; pull value
.0956	aa		tax			TAX  			; restore X
.0957	68		pla			PLA			    ; pull value
.0958	a8		tay			TAY  			; restore Y
.0959	68		pla			PLA  			; restore A
.095a	60		rts			RTS

;******  End of listing
